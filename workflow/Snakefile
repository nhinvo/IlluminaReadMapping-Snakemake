from pathlib import Path
import pandas as pd

### Load samples.tsv file and obtain list of samples ###
SAMPLE_TABLE = pd.read_csv(config["input"]["sample table"], index_col="sample", sep="\t")
SAMPLE_TABLE.index = SAMPLE_TABLE.index.map(str)  # convert index (samples) to string 
SAMPLES = SAMPLE_TABLE.index.tolist()  # obtain list of samples 

##### Define intermediate/results files/directories #####
scratch_dir = Path(config["scratch directory"])
results_dir = Path(config["results directory"])

Path(scratch_dir).mkdir(exist_ok=True, parents=True)
Path(results_dir).mkdir(exist_ok=True, parents=True)

scratch_dict = {
    "QC": scratch_dir / "QC",  # QC: read trimming/filtering
    "genome_assembly": scratch_dir / "genome_assembly",  # read assembly 
    "read_mapping": scratch_dir / "read_mapping",  # read mapping (pre-binning)

}

results_dict = {
    # binning, quality, and classification final table
    'aggregate_table': results_dir / "aggregate_table.tsv", 
}

##### Define the file files to generate #####
rule all:
    input:
        expand(scratch_dict["read_mapping"] / "{sample}.cov", sample=SAMPLES)

##### Define rules #####
rule run_trim_PE:
    input:
        r1 = lambda wildcards: SAMPLE_TABLE.loc[wildcards.sample, 'forward read'],
        r2 = lambda wildcards: SAMPLE_TABLE.loc[wildcards.sample, 'reverse read'],
        ref = config["input"]["adapter_file"],
    output:
        o1 = scratch_dict["QC"] / "{sample}_1_trimmed.fastq.gz",
        o2 = scratch_dict["QC"] / "{sample}_2_trimmed.fastq.gz",
    conda:
        "envs/bbtools.yaml"
    shell:
        "bbduk.sh threads={resources.cpus_per_task} "
        "in1={input.r1} in2={input.r2} "
        "out1={output.o1} out2={output.o2} "
        "minlen=25 qtrim=rl trimq=10 "
        "ref={input.ref} ktrim=r k=23 mink=11 hdist=1"

rule map_reads:
    """
    Index reference assembly and map reads to obtain coverage for binning. 

    Credit: Konnor von Emster.
    """
    input: 
        trimmed_r1 = scratch_dict["QC"] / "{sample}_1_trimmed.fastq.gz",
        trimmed_r2 = scratch_dict["QC"] / "{sample}_2_trimmed.fastq.gz",
        ref_genome = lambda wildcards: SAMPLE_TABLE.loc[wildcards.sample, 'ref_genome'],
    output: 
        temp(scratch_dict["read_mapping"] / "{sample}.sam"),
    conda: 
        "envs/bowtie2.yaml"
    shell: 
        """
        # index reference assembly
        bowtie2-build \
            --threads {resources.cpus_per_task} \
            {input.ref_genome} \
            {input.ref_genome}

        # map reads 
        bowtie2 \
            --threads {resources.cpus_per_task} \
            -x {input.ref_genome} \
            -1 {input.trimmed_r1} \
            -2 {input.trimmed_r2} \
            -S {output} 
        """

rule samtools_view:
    """
    Convert sam to bam.
    """
    input: scratch_dict["read_mapping"] / "{sample}.sam", 
    output: temp(scratch_dict["read_mapping"] / "{sample}.bam"), 
    conda: "envs/samtools.yaml"
    shell:
        """
        samtools view \
            --bam \
            --threads {resources.cpus_per_task} \
            --output {output} \
            {input}
        """

rule samtools_sort_index:
    """
    Sort index bam. 
    """
    input: 
        scratch_dict["read_mapping"] / "{sample}.bam", 
    output: 
        sorted_bam = scratch_dict["read_mapping"] / "{sample}_sorted.bam", 
        indexed_bam = scratch_dict["read_mapping"] / "{sample}_sorted.bam.bai", 
    conda: 
        "envs/samtools.yaml"
    shell:
        """
        # sort bam 
        samtools sort \
            --threads {resources.cpus_per_task} \
            -o {output.sorted_bam} \
            {input}

        # index the sorted_bam
        samtools index \
            --threads {resources.cpus_per_task} \
            --bai \
            --output {output.indexed_bam} \
            {output.sorted_bam}
        """

rule samtools_depth:
    """
    Obtain coverage at each position. 
    """
    input: scratch_dict["read_mapping"] / "{sample}_sorted.bam", 
    output: scratch_dict["read_mapping"] / "{sample}.cov", 
    conda: "envs/samtools.yaml"
    shell: "samtools depth -o {output} {input}"

